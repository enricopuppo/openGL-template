#include "ObjectShader.hpp"
#include "ShaderProgram.hpp"
#include "Camera.hpp"
#include "Light.hpp"
#include "MatrixGenerator.hpp"
#include <string>
#include "./glm/glm.hpp"
#include <vector>
#include <string>

ObjectShader::ObjectShader(const std::string vsSource, const std::string fsSource) : ShaderProgram::ShaderProgram(vsSource, fsSource){
    // generates a shader program and sets the maximum number of managed lights
    this->maxLights = 4;
}

void ObjectShader::bindAttribute(int attr, std::string varName){
    ShaderProgram::bindAttribute(attr, varName);
}

void ObjectShader::bindAttributes(){
    ObjectShader::bindAttribute(0, "position");
    ObjectShader::bindAttribute(1, "textureCoords");
    ObjectShader::bindAttribute(2, "normal");
}

void ObjectShader::getUniformLocations(){
    // gets the location of all the needed uniforms
    loc_transformationMatrix = ShaderProgram::getUniformLocation("transformationMatrix");
    loc_projectionMatrix = ShaderProgram::getUniformLocation("projectionMatrix");
    loc_viewMatrix = ShaderProgram::getUniformLocation("viewMatrix");
    loc_shineDamper = ShaderProgram::getUniformLocation("shineDamper");
    loc_reflectivity = ShaderProgram::getUniformLocation("reflectivity");
    loc_texture = ShaderProgram::getUniformLocation("textureSampler");
    for(int i=0; i<maxLights; i++){
        loc_lightPosition.push_back(ShaderProgram::getUniformLocation("lightPosition["  + std::to_string(i) + "]"));
        loc_lightColor.push_back(ShaderProgram::getUniformLocation("lightColor[" + std::to_string(i) + "]"));
        loc_attenuation.push_back(ShaderProgram::getUniformLocation("attenuation[" + std::to_string(i) + "]"));
    }
    loc_clipPlane = ShaderProgram::getUniformLocation("clipPlane");
}

void ObjectShader::loadTransformationMatrix(glm::mat4 matrix){
    ShaderProgram::loadMatrix(loc_transformationMatrix, matrix);
}

void ObjectShader::loadProjectionMatrix(glm::mat4 matrix){
    ShaderProgram::loadMatrix(loc_projectionMatrix, matrix);
}

void ObjectShader::loadViewMatrix(Camera &camera){
    // loads the view matrix.
    // the third person view uses the one generated by the arcball
    if(camera.isFirstPersonViewEnabled()){
        MatrixGenerator mg = MatrixGenerator();
        ShaderProgram::loadMatrix(loc_viewMatrix, mg.createViewMatrix(camera));
    }
    else
        ShaderProgram::loadMatrix(loc_viewMatrix, camera.getViewMatrix());
}

void ObjectShader::loadClipPlane(glm::vec4 plane){
    ShaderProgram::loadVector(loc_clipPlane, plane);
}

void ObjectShader::loadLights(std::vector<Light> &lights){
    for(int i=0; i<maxLights; ++i){     // accepts max 4 lights
        if((size_t)i<lights.size()){
            loadVector(loc_lightPosition[i], lights[i].getPosition());
            loadVector(loc_lightColor[i], lights[i].getColor());
            loadVector(loc_attenuation[i], lights[i].getAttenuation());
       }
       else{    // if less are given we add some dummy input to fill the array
            loadVector(loc_lightPosition[i], glm::vec3(0.0, 0.0, 0.0));
            loadVector(loc_lightColor[i], glm::vec3(0.0, 0.0, 0.0));
            loadVector(loc_attenuation[i], glm::vec3(1.0, 0.0, 0.0));
       }
    }
}

void ObjectShader::loadShineVars(float damper, float reflectivity){
    ShaderProgram::loadFloat(loc_shineDamper, damper);
    ShaderProgram::loadFloat(loc_reflectivity, reflectivity);
}